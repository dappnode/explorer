{"version":3,"sources":["components/Header.tsx","components/ActivityChart.tsx","generated/graphql.tsx","components/SummaryStats.tsx","settingsContext.ts","utils/format.ts","utils/url.ts","components/TimeDisplay.tsx","components/SummaryTable.tsx","utils/math.ts","pages/Home.tsx","utils/isVersionAvailable.ts","components/StatusBubble.tsx","components/ExternalLink.tsx","components/AddressDisplay.tsx","components/VersionDisplay.tsx","pages/Repo/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Header","className","to","renderColorfulLegendText","value","style","color","fontSize","CustomTooltip","active","payload","label","reverse","map","name","key","monthNumToShort","month","mockDate","Date","getTime","Intl","DateTimeFormat","format","ActivityChart","data","activity","versions","v","i","count","packages","parseActivity","height","dataKey","stroke","tick","fill","isAnimationActive","cursor","content","formatter","maxBarSize","stackId","IpfsHash_OrderBy","OrderDirection","Registry_OrderBy","Repo_OrderBy","Version_OrderBy","ReposDocument","gql","RepoDocument","CountDocument","ActivityDocument","SummaryStats","baseOptions","ApolloReactHooks","registries","packageCount","reduce","total","reg","repoCount","versionCount","cards","title","stat","Icon","GoPackage","MdUpdate","SettingsContext","React","createContext","ipfsGateway","ipfsApi","txViewer","Provider","Consumer","capitalize","s","charAt","toUpperCase","slice","prettyName","replace","split","join","semanticVersionDots","semanticVersion","urlJoin","args","stipIpfsPrefix","ipfsDirtyHash","joinIpfsLocation","location","TimeDisplay","timestamp","time","moment","calendar","fromNow","SummaryTable","useState","showIndex","setShowIndex","history","useHistory","useContext","reposSummary","useEffect","onScroll","window","innerHeight","document","documentElement","scrollTop","offsetHeight","x","repos","length","addEventListener","removeEventListener","sort","a","b","lastVersion","id","registryName","onClick","push","src","contentUri","alt","RegistryDisplay","registry","small","error","message","loading","shortName","undefined","prettyRegistry","aggregateLast12Months","items","getFullMonth","date","getFullYear","getMonth","byTime","item","fullMonth","currentFullMonth","aggregate","Home","activityQuery","isVersionAvailable","version","url","ky","timeout","json","Boolean","CumulativeSize","console","log","StatusBubble","ok","status","ExternalLink","href","rel","target","AddressDisplay","address","makeBlockie","prettyAddress","VersionDisplay","isLatest","frameBorder","Repo","match","isAvailable","setIsAvailable","analyze","setAnalyze","params","repoId","versionId","repoQuery","variables","repoData","repo","_version","available","checkVersionAvailability","index","firstVersion","txHash","sender","latestVersionIndex","versionDisplay","find","App","path","exact","component","hostname","client","ApolloClient","uri","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.d697272e.chunk.js","sourcesContent":["import React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport \"./header.scss\";\n\nexport default function Header() {\n  return (\n    <div className=\"app-header\">\n      <div className=\"app-container\">\n        <Link to=\"/\">\n          <h1>\n            <span className=\"dappnode\">DAppNode</span>\n            <span className=\"explorer\">EXPLORER</span>\n          </h1>\n        </Link>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\nimport {\n  BarChart,\n  Bar,\n  XAxis,\n  Legend,\n  ResponsiveContainer,\n  Tooltip,\n} from \"recharts\";\nimport \"./activity-chart.scss\";\n\nconst maxHeight = 200;\nconst mainColor = \"#2fbcb2\";\nconst bColor = \"#bc7a2f\"; // Alternative strong color\nconst softColor = \"#767e86\"; // soft\nconst borderColor = \"#2c3034\"; // Very very soft\nconst packagesName = \"new packages\";\nconst versionsName = \"new versions\";\nconst fontSize = 12.8;\n\ninterface RechartsTooltipPayload {\n  fill: string; // \"#bc7a2f\";\n  dataKey: string; // \"packages\";\n  name: string; // \"packages\";\n  color: string; // \"#bc7a2f\";\n  value: number; // 0;\n}\n\nfunction renderColorfulLegendText(value: string) {\n  return <span style={{ color: softColor, fontSize }}>{value}</span>;\n}\n\nfunction CustomTooltip({\n  active,\n  payload = [],\n  label,\n}: {\n  active: boolean;\n  payload: RechartsTooltipPayload[];\n  label: string;\n}) {\n  if (!active || !payload) return null;\n  return (\n    <div className=\"custom-recharts-tooltip\">\n      <div>{label}</div>\n      <table>\n        <tbody>\n          {payload.reverse().map(({ name, color, value }) => (\n            <tr key={name} style={{ color }}>\n              <td>{value}</td>\n              <td>{name}</td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\ninterface ActivityByMonth {\n  month: number;\n  count: number;\n}\n\ninterface ActivityData {\n  month: string; // \"Jan\";\n  versions: number; // 13;\n  packages: number; // 2;\n}\n\ninterface Activity {\n  versions: ActivityByMonth[];\n  packages: ActivityByMonth[];\n}\n\n/**\n * Parses a numeric month to its short english name\n * @param month 0\n * @returns Jan\n */\nfunction monthNumToShort(month: number) {\n  const mockDate = new Date(new Date(`2020/${month + 1}/1`).getTime()); // UTC date - Safari bug /-\n  return new Intl.DateTimeFormat(\"en-US\", { month: \"short\" }).format(mockDate);\n}\n\nfunction parseActivity(activity?: Activity): ActivityData[] {\n  if (!activity) return [];\n  return activity.versions.map((v, i) => ({\n    month: monthNumToShort(v.month),\n    versions: (activity.versions[i] || {}).count || 0,\n    packages: (activity.packages[i] || {}).count || 0,\n  }));\n}\n\nexport default function ActivityChart({ activity }: { activity?: Activity }) {\n  const data = parseActivity(activity);\n  return (\n    <div className=\"activity-chart\">\n      <div className=\"header\">\n        <div className=\"time\">LAST 12 MONTHS</div>\n        <div className=\"name\">ACTIVITY</div>\n      </div>\n\n      <ResponsiveContainer height={maxHeight}>\n        <BarChart data={data}>\n          <XAxis\n            dataKey=\"month\"\n            stroke={borderColor}\n            tick={{ fill: softColor, fontSize }}\n          />\n          <Tooltip\n            isAnimationActive={false}\n            cursor={{ fill: \"transparent\" }}\n            content={CustomTooltip}\n          />\n          <Legend formatter={renderColorfulLegendText} />\n          <Bar\n            isAnimationActive={false}\n            maxBarSize={20}\n            dataKey=\"packages\"\n            name={packagesName}\n            stackId=\"a\"\n            fill={bColor}\n          />\n          <Bar\n            isAnimationActive={false}\n            maxBarSize={20}\n            dataKey=\"versions\"\n            name={versionsName}\n            stackId=\"a\"\n            fill={mainColor}\n          />\n        </BarChart>\n      </ResponsiveContainer>\n    </div>\n  );\n}\n","import gql from 'graphql-tag';\nimport * as React from 'react';\nimport * as ApolloReactCommon from '@apollo/react-common';\nimport * as ApolloReactComponents from '@apollo/react-components';\nimport * as ApolloReactHoc from '@apollo/react-hoc';\nimport * as ApolloReactHooks from '@apollo/react-hooks';\nexport type Maybe<T> = T | null;\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  BigDecimal: any;\n  BigInt: any;\n  Bytes: any;\n};\n\n\n\nexport type Block_Height = {\n  hash?: Maybe<Scalars['Bytes']>;\n  number?: Maybe<Scalars['Int']>;\n};\n\n\nexport type IpfsHash = {\n  __typename?: 'IpfsHash';\n  id: Scalars['ID'];\n  hash?: Maybe<Scalars['String']>;\n};\n\nexport type IpfsHash_Filter = {\n  id?: Maybe<Scalars['ID']>;\n  id_not?: Maybe<Scalars['ID']>;\n  id_gt?: Maybe<Scalars['ID']>;\n  id_lt?: Maybe<Scalars['ID']>;\n  id_gte?: Maybe<Scalars['ID']>;\n  id_lte?: Maybe<Scalars['ID']>;\n  id_in?: Maybe<Array<Scalars['ID']>>;\n  id_not_in?: Maybe<Array<Scalars['ID']>>;\n  hash?: Maybe<Scalars['String']>;\n  hash_not?: Maybe<Scalars['String']>;\n  hash_gt?: Maybe<Scalars['String']>;\n  hash_lt?: Maybe<Scalars['String']>;\n  hash_gte?: Maybe<Scalars['String']>;\n  hash_lte?: Maybe<Scalars['String']>;\n  hash_in?: Maybe<Array<Scalars['String']>>;\n  hash_not_in?: Maybe<Array<Scalars['String']>>;\n  hash_contains?: Maybe<Scalars['String']>;\n  hash_not_contains?: Maybe<Scalars['String']>;\n  hash_starts_with?: Maybe<Scalars['String']>;\n  hash_not_starts_with?: Maybe<Scalars['String']>;\n  hash_ends_with?: Maybe<Scalars['String']>;\n  hash_not_ends_with?: Maybe<Scalars['String']>;\n};\n\nexport enum IpfsHash_OrderBy {\n  Id = 'id',\n  Hash = 'hash'\n}\n\nexport enum OrderDirection {\n  Asc = 'asc',\n  Desc = 'desc'\n}\n\nexport type Query = {\n  __typename?: 'Query';\n  registry?: Maybe<Registry>;\n  registries: Array<Registry>;\n  repo?: Maybe<Repo>;\n  repos: Array<Repo>;\n  version?: Maybe<Version>;\n  versions: Array<Version>;\n  ipfsHash?: Maybe<IpfsHash>;\n  ipfsHashes: Array<IpfsHash>;\n};\n\n\nexport type QueryRegistryArgs = {\n  id: Scalars['ID'];\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type QueryRegistriesArgs = {\n  skip?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<Registry_OrderBy>;\n  orderDirection?: Maybe<OrderDirection>;\n  where?: Maybe<Registry_Filter>;\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type QueryRepoArgs = {\n  id: Scalars['ID'];\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type QueryReposArgs = {\n  skip?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<Repo_OrderBy>;\n  orderDirection?: Maybe<OrderDirection>;\n  where?: Maybe<Repo_Filter>;\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type QueryVersionArgs = {\n  id: Scalars['ID'];\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type QueryVersionsArgs = {\n  skip?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<Version_OrderBy>;\n  orderDirection?: Maybe<OrderDirection>;\n  where?: Maybe<Version_Filter>;\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type QueryIpfsHashArgs = {\n  id: Scalars['ID'];\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type QueryIpfsHashesArgs = {\n  skip?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<IpfsHash_OrderBy>;\n  orderDirection?: Maybe<OrderDirection>;\n  where?: Maybe<IpfsHash_Filter>;\n  block?: Maybe<Block_Height>;\n};\n\nexport type Registry = {\n  __typename?: 'Registry';\n  id: Scalars['ID'];\n  address: Scalars['Bytes'];\n  name: Scalars['String'];\n  repoCount: Scalars['Int'];\n  versionCount: Scalars['Int'];\n  repos?: Maybe<Array<Repo>>;\n};\n\n\nexport type RegistryReposArgs = {\n  skip?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<Repo_OrderBy>;\n  orderDirection?: Maybe<OrderDirection>;\n  where?: Maybe<Repo_Filter>;\n};\n\nexport type Registry_Filter = {\n  id?: Maybe<Scalars['ID']>;\n  id_not?: Maybe<Scalars['ID']>;\n  id_gt?: Maybe<Scalars['ID']>;\n  id_lt?: Maybe<Scalars['ID']>;\n  id_gte?: Maybe<Scalars['ID']>;\n  id_lte?: Maybe<Scalars['ID']>;\n  id_in?: Maybe<Array<Scalars['ID']>>;\n  id_not_in?: Maybe<Array<Scalars['ID']>>;\n  address?: Maybe<Scalars['Bytes']>;\n  address_not?: Maybe<Scalars['Bytes']>;\n  address_in?: Maybe<Array<Scalars['Bytes']>>;\n  address_not_in?: Maybe<Array<Scalars['Bytes']>>;\n  address_contains?: Maybe<Scalars['Bytes']>;\n  address_not_contains?: Maybe<Scalars['Bytes']>;\n  name?: Maybe<Scalars['String']>;\n  name_not?: Maybe<Scalars['String']>;\n  name_gt?: Maybe<Scalars['String']>;\n  name_lt?: Maybe<Scalars['String']>;\n  name_gte?: Maybe<Scalars['String']>;\n  name_lte?: Maybe<Scalars['String']>;\n  name_in?: Maybe<Array<Scalars['String']>>;\n  name_not_in?: Maybe<Array<Scalars['String']>>;\n  name_contains?: Maybe<Scalars['String']>;\n  name_not_contains?: Maybe<Scalars['String']>;\n  name_starts_with?: Maybe<Scalars['String']>;\n  name_not_starts_with?: Maybe<Scalars['String']>;\n  name_ends_with?: Maybe<Scalars['String']>;\n  name_not_ends_with?: Maybe<Scalars['String']>;\n  repoCount?: Maybe<Scalars['Int']>;\n  repoCount_not?: Maybe<Scalars['Int']>;\n  repoCount_gt?: Maybe<Scalars['Int']>;\n  repoCount_lt?: Maybe<Scalars['Int']>;\n  repoCount_gte?: Maybe<Scalars['Int']>;\n  repoCount_lte?: Maybe<Scalars['Int']>;\n  repoCount_in?: Maybe<Array<Scalars['Int']>>;\n  repoCount_not_in?: Maybe<Array<Scalars['Int']>>;\n  versionCount?: Maybe<Scalars['Int']>;\n  versionCount_not?: Maybe<Scalars['Int']>;\n  versionCount_gt?: Maybe<Scalars['Int']>;\n  versionCount_lt?: Maybe<Scalars['Int']>;\n  versionCount_gte?: Maybe<Scalars['Int']>;\n  versionCount_lte?: Maybe<Scalars['Int']>;\n  versionCount_in?: Maybe<Array<Scalars['Int']>>;\n  versionCount_not_in?: Maybe<Array<Scalars['Int']>>;\n  repos?: Maybe<Array<Scalars['String']>>;\n  repos_not?: Maybe<Array<Scalars['String']>>;\n  repos_contains?: Maybe<Array<Scalars['String']>>;\n  repos_not_contains?: Maybe<Array<Scalars['String']>>;\n};\n\nexport enum Registry_OrderBy {\n  Id = 'id',\n  Address = 'address',\n  Name = 'name',\n  RepoCount = 'repoCount',\n  VersionCount = 'versionCount',\n  Repos = 'repos'\n}\n\nexport type Repo = {\n  __typename?: 'Repo';\n  id: Scalars['ID'];\n  address: Scalars['Bytes'];\n  name: Scalars['String'];\n  node: Scalars['Bytes'];\n  timestamp: Scalars['Int'];\n  txHash: Scalars['Bytes'];\n  sender: Scalars['Bytes'];\n  lastVersion?: Maybe<Version>;\n  versionCount: Scalars['Int'];\n  versions?: Maybe<Array<Version>>;\n  registry: Registry;\n  registryName: Scalars['String'];\n  registryId: Scalars['String'];\n};\n\n\nexport type RepoVersionsArgs = {\n  skip?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<Version_OrderBy>;\n  orderDirection?: Maybe<OrderDirection>;\n  where?: Maybe<Version_Filter>;\n};\n\nexport type Repo_Filter = {\n  id?: Maybe<Scalars['ID']>;\n  id_not?: Maybe<Scalars['ID']>;\n  id_gt?: Maybe<Scalars['ID']>;\n  id_lt?: Maybe<Scalars['ID']>;\n  id_gte?: Maybe<Scalars['ID']>;\n  id_lte?: Maybe<Scalars['ID']>;\n  id_in?: Maybe<Array<Scalars['ID']>>;\n  id_not_in?: Maybe<Array<Scalars['ID']>>;\n  address?: Maybe<Scalars['Bytes']>;\n  address_not?: Maybe<Scalars['Bytes']>;\n  address_in?: Maybe<Array<Scalars['Bytes']>>;\n  address_not_in?: Maybe<Array<Scalars['Bytes']>>;\n  address_contains?: Maybe<Scalars['Bytes']>;\n  address_not_contains?: Maybe<Scalars['Bytes']>;\n  name?: Maybe<Scalars['String']>;\n  name_not?: Maybe<Scalars['String']>;\n  name_gt?: Maybe<Scalars['String']>;\n  name_lt?: Maybe<Scalars['String']>;\n  name_gte?: Maybe<Scalars['String']>;\n  name_lte?: Maybe<Scalars['String']>;\n  name_in?: Maybe<Array<Scalars['String']>>;\n  name_not_in?: Maybe<Array<Scalars['String']>>;\n  name_contains?: Maybe<Scalars['String']>;\n  name_not_contains?: Maybe<Scalars['String']>;\n  name_starts_with?: Maybe<Scalars['String']>;\n  name_not_starts_with?: Maybe<Scalars['String']>;\n  name_ends_with?: Maybe<Scalars['String']>;\n  name_not_ends_with?: Maybe<Scalars['String']>;\n  node?: Maybe<Scalars['Bytes']>;\n  node_not?: Maybe<Scalars['Bytes']>;\n  node_in?: Maybe<Array<Scalars['Bytes']>>;\n  node_not_in?: Maybe<Array<Scalars['Bytes']>>;\n  node_contains?: Maybe<Scalars['Bytes']>;\n  node_not_contains?: Maybe<Scalars['Bytes']>;\n  timestamp?: Maybe<Scalars['Int']>;\n  timestamp_not?: Maybe<Scalars['Int']>;\n  timestamp_gt?: Maybe<Scalars['Int']>;\n  timestamp_lt?: Maybe<Scalars['Int']>;\n  timestamp_gte?: Maybe<Scalars['Int']>;\n  timestamp_lte?: Maybe<Scalars['Int']>;\n  timestamp_in?: Maybe<Array<Scalars['Int']>>;\n  timestamp_not_in?: Maybe<Array<Scalars['Int']>>;\n  txHash?: Maybe<Scalars['Bytes']>;\n  txHash_not?: Maybe<Scalars['Bytes']>;\n  txHash_in?: Maybe<Array<Scalars['Bytes']>>;\n  txHash_not_in?: Maybe<Array<Scalars['Bytes']>>;\n  txHash_contains?: Maybe<Scalars['Bytes']>;\n  txHash_not_contains?: Maybe<Scalars['Bytes']>;\n  sender?: Maybe<Scalars['Bytes']>;\n  sender_not?: Maybe<Scalars['Bytes']>;\n  sender_in?: Maybe<Array<Scalars['Bytes']>>;\n  sender_not_in?: Maybe<Array<Scalars['Bytes']>>;\n  sender_contains?: Maybe<Scalars['Bytes']>;\n  sender_not_contains?: Maybe<Scalars['Bytes']>;\n  lastVersion?: Maybe<Scalars['String']>;\n  lastVersion_not?: Maybe<Scalars['String']>;\n  lastVersion_gt?: Maybe<Scalars['String']>;\n  lastVersion_lt?: Maybe<Scalars['String']>;\n  lastVersion_gte?: Maybe<Scalars['String']>;\n  lastVersion_lte?: Maybe<Scalars['String']>;\n  lastVersion_in?: Maybe<Array<Scalars['String']>>;\n  lastVersion_not_in?: Maybe<Array<Scalars['String']>>;\n  lastVersion_contains?: Maybe<Scalars['String']>;\n  lastVersion_not_contains?: Maybe<Scalars['String']>;\n  lastVersion_starts_with?: Maybe<Scalars['String']>;\n  lastVersion_not_starts_with?: Maybe<Scalars['String']>;\n  lastVersion_ends_with?: Maybe<Scalars['String']>;\n  lastVersion_not_ends_with?: Maybe<Scalars['String']>;\n  versionCount?: Maybe<Scalars['Int']>;\n  versionCount_not?: Maybe<Scalars['Int']>;\n  versionCount_gt?: Maybe<Scalars['Int']>;\n  versionCount_lt?: Maybe<Scalars['Int']>;\n  versionCount_gte?: Maybe<Scalars['Int']>;\n  versionCount_lte?: Maybe<Scalars['Int']>;\n  versionCount_in?: Maybe<Array<Scalars['Int']>>;\n  versionCount_not_in?: Maybe<Array<Scalars['Int']>>;\n  versions?: Maybe<Array<Scalars['String']>>;\n  versions_not?: Maybe<Array<Scalars['String']>>;\n  versions_contains?: Maybe<Array<Scalars['String']>>;\n  versions_not_contains?: Maybe<Array<Scalars['String']>>;\n  registryName?: Maybe<Scalars['String']>;\n  registryName_not?: Maybe<Scalars['String']>;\n  registryName_gt?: Maybe<Scalars['String']>;\n  registryName_lt?: Maybe<Scalars['String']>;\n  registryName_gte?: Maybe<Scalars['String']>;\n  registryName_lte?: Maybe<Scalars['String']>;\n  registryName_in?: Maybe<Array<Scalars['String']>>;\n  registryName_not_in?: Maybe<Array<Scalars['String']>>;\n  registryName_contains?: Maybe<Scalars['String']>;\n  registryName_not_contains?: Maybe<Scalars['String']>;\n  registryName_starts_with?: Maybe<Scalars['String']>;\n  registryName_not_starts_with?: Maybe<Scalars['String']>;\n  registryName_ends_with?: Maybe<Scalars['String']>;\n  registryName_not_ends_with?: Maybe<Scalars['String']>;\n  registryId?: Maybe<Scalars['String']>;\n  registryId_not?: Maybe<Scalars['String']>;\n  registryId_gt?: Maybe<Scalars['String']>;\n  registryId_lt?: Maybe<Scalars['String']>;\n  registryId_gte?: Maybe<Scalars['String']>;\n  registryId_lte?: Maybe<Scalars['String']>;\n  registryId_in?: Maybe<Array<Scalars['String']>>;\n  registryId_not_in?: Maybe<Array<Scalars['String']>>;\n  registryId_contains?: Maybe<Scalars['String']>;\n  registryId_not_contains?: Maybe<Scalars['String']>;\n  registryId_starts_with?: Maybe<Scalars['String']>;\n  registryId_not_starts_with?: Maybe<Scalars['String']>;\n  registryId_ends_with?: Maybe<Scalars['String']>;\n  registryId_not_ends_with?: Maybe<Scalars['String']>;\n};\n\nexport enum Repo_OrderBy {\n  Id = 'id',\n  Address = 'address',\n  Name = 'name',\n  Node = 'node',\n  Timestamp = 'timestamp',\n  TxHash = 'txHash',\n  Sender = 'sender',\n  LastVersion = 'lastVersion',\n  VersionCount = 'versionCount',\n  Versions = 'versions',\n  Registry = 'registry',\n  RegistryName = 'registryName',\n  RegistryId = 'registryId'\n}\n\nexport type Subscription = {\n  __typename?: 'Subscription';\n  registry?: Maybe<Registry>;\n  registries: Array<Registry>;\n  repo?: Maybe<Repo>;\n  repos: Array<Repo>;\n  version?: Maybe<Version>;\n  versions: Array<Version>;\n  ipfsHash?: Maybe<IpfsHash>;\n  ipfsHashes: Array<IpfsHash>;\n};\n\n\nexport type SubscriptionRegistryArgs = {\n  id: Scalars['ID'];\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type SubscriptionRegistriesArgs = {\n  skip?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<Registry_OrderBy>;\n  orderDirection?: Maybe<OrderDirection>;\n  where?: Maybe<Registry_Filter>;\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type SubscriptionRepoArgs = {\n  id: Scalars['ID'];\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type SubscriptionReposArgs = {\n  skip?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<Repo_OrderBy>;\n  orderDirection?: Maybe<OrderDirection>;\n  where?: Maybe<Repo_Filter>;\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type SubscriptionVersionArgs = {\n  id: Scalars['ID'];\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type SubscriptionVersionsArgs = {\n  skip?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<Version_OrderBy>;\n  orderDirection?: Maybe<OrderDirection>;\n  where?: Maybe<Version_Filter>;\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type SubscriptionIpfsHashArgs = {\n  id: Scalars['ID'];\n  block?: Maybe<Block_Height>;\n};\n\n\nexport type SubscriptionIpfsHashesArgs = {\n  skip?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<IpfsHash_OrderBy>;\n  orderDirection?: Maybe<OrderDirection>;\n  where?: Maybe<IpfsHash_Filter>;\n  block?: Maybe<Block_Height>;\n};\n\nexport type Version = {\n  __typename?: 'Version';\n  id: Scalars['ID'];\n  semanticVersion: Scalars['String'];\n  codeAddress: Scalars['Bytes'];\n  contentUri: Scalars['String'];\n  index: Scalars['Int'];\n  timestamp: Scalars['Int'];\n  txHash: Scalars['Bytes'];\n  sender: Scalars['Bytes'];\n  repoName: Scalars['String'];\n  repoAddress: Scalars['Bytes'];\n  repoNamehash: Scalars['Bytes'];\n  registryName: Scalars['String'];\n};\n\nexport type Version_Filter = {\n  id?: Maybe<Scalars['ID']>;\n  id_not?: Maybe<Scalars['ID']>;\n  id_gt?: Maybe<Scalars['ID']>;\n  id_lt?: Maybe<Scalars['ID']>;\n  id_gte?: Maybe<Scalars['ID']>;\n  id_lte?: Maybe<Scalars['ID']>;\n  id_in?: Maybe<Array<Scalars['ID']>>;\n  id_not_in?: Maybe<Array<Scalars['ID']>>;\n  semanticVersion?: Maybe<Scalars['String']>;\n  semanticVersion_not?: Maybe<Scalars['String']>;\n  semanticVersion_gt?: Maybe<Scalars['String']>;\n  semanticVersion_lt?: Maybe<Scalars['String']>;\n  semanticVersion_gte?: Maybe<Scalars['String']>;\n  semanticVersion_lte?: Maybe<Scalars['String']>;\n  semanticVersion_in?: Maybe<Array<Scalars['String']>>;\n  semanticVersion_not_in?: Maybe<Array<Scalars['String']>>;\n  semanticVersion_contains?: Maybe<Scalars['String']>;\n  semanticVersion_not_contains?: Maybe<Scalars['String']>;\n  semanticVersion_starts_with?: Maybe<Scalars['String']>;\n  semanticVersion_not_starts_with?: Maybe<Scalars['String']>;\n  semanticVersion_ends_with?: Maybe<Scalars['String']>;\n  semanticVersion_not_ends_with?: Maybe<Scalars['String']>;\n  codeAddress?: Maybe<Scalars['Bytes']>;\n  codeAddress_not?: Maybe<Scalars['Bytes']>;\n  codeAddress_in?: Maybe<Array<Scalars['Bytes']>>;\n  codeAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;\n  codeAddress_contains?: Maybe<Scalars['Bytes']>;\n  codeAddress_not_contains?: Maybe<Scalars['Bytes']>;\n  contentUri?: Maybe<Scalars['String']>;\n  contentUri_not?: Maybe<Scalars['String']>;\n  contentUri_gt?: Maybe<Scalars['String']>;\n  contentUri_lt?: Maybe<Scalars['String']>;\n  contentUri_gte?: Maybe<Scalars['String']>;\n  contentUri_lte?: Maybe<Scalars['String']>;\n  contentUri_in?: Maybe<Array<Scalars['String']>>;\n  contentUri_not_in?: Maybe<Array<Scalars['String']>>;\n  contentUri_contains?: Maybe<Scalars['String']>;\n  contentUri_not_contains?: Maybe<Scalars['String']>;\n  contentUri_starts_with?: Maybe<Scalars['String']>;\n  contentUri_not_starts_with?: Maybe<Scalars['String']>;\n  contentUri_ends_with?: Maybe<Scalars['String']>;\n  contentUri_not_ends_with?: Maybe<Scalars['String']>;\n  index?: Maybe<Scalars['Int']>;\n  index_not?: Maybe<Scalars['Int']>;\n  index_gt?: Maybe<Scalars['Int']>;\n  index_lt?: Maybe<Scalars['Int']>;\n  index_gte?: Maybe<Scalars['Int']>;\n  index_lte?: Maybe<Scalars['Int']>;\n  index_in?: Maybe<Array<Scalars['Int']>>;\n  index_not_in?: Maybe<Array<Scalars['Int']>>;\n  timestamp?: Maybe<Scalars['Int']>;\n  timestamp_not?: Maybe<Scalars['Int']>;\n  timestamp_gt?: Maybe<Scalars['Int']>;\n  timestamp_lt?: Maybe<Scalars['Int']>;\n  timestamp_gte?: Maybe<Scalars['Int']>;\n  timestamp_lte?: Maybe<Scalars['Int']>;\n  timestamp_in?: Maybe<Array<Scalars['Int']>>;\n  timestamp_not_in?: Maybe<Array<Scalars['Int']>>;\n  txHash?: Maybe<Scalars['Bytes']>;\n  txHash_not?: Maybe<Scalars['Bytes']>;\n  txHash_in?: Maybe<Array<Scalars['Bytes']>>;\n  txHash_not_in?: Maybe<Array<Scalars['Bytes']>>;\n  txHash_contains?: Maybe<Scalars['Bytes']>;\n  txHash_not_contains?: Maybe<Scalars['Bytes']>;\n  sender?: Maybe<Scalars['Bytes']>;\n  sender_not?: Maybe<Scalars['Bytes']>;\n  sender_in?: Maybe<Array<Scalars['Bytes']>>;\n  sender_not_in?: Maybe<Array<Scalars['Bytes']>>;\n  sender_contains?: Maybe<Scalars['Bytes']>;\n  sender_not_contains?: Maybe<Scalars['Bytes']>;\n  repoName?: Maybe<Scalars['String']>;\n  repoName_not?: Maybe<Scalars['String']>;\n  repoName_gt?: Maybe<Scalars['String']>;\n  repoName_lt?: Maybe<Scalars['String']>;\n  repoName_gte?: Maybe<Scalars['String']>;\n  repoName_lte?: Maybe<Scalars['String']>;\n  repoName_in?: Maybe<Array<Scalars['String']>>;\n  repoName_not_in?: Maybe<Array<Scalars['String']>>;\n  repoName_contains?: Maybe<Scalars['String']>;\n  repoName_not_contains?: Maybe<Scalars['String']>;\n  repoName_starts_with?: Maybe<Scalars['String']>;\n  repoName_not_starts_with?: Maybe<Scalars['String']>;\n  repoName_ends_with?: Maybe<Scalars['String']>;\n  repoName_not_ends_with?: Maybe<Scalars['String']>;\n  repoAddress?: Maybe<Scalars['Bytes']>;\n  repoAddress_not?: Maybe<Scalars['Bytes']>;\n  repoAddress_in?: Maybe<Array<Scalars['Bytes']>>;\n  repoAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;\n  repoAddress_contains?: Maybe<Scalars['Bytes']>;\n  repoAddress_not_contains?: Maybe<Scalars['Bytes']>;\n  repoNamehash?: Maybe<Scalars['Bytes']>;\n  repoNamehash_not?: Maybe<Scalars['Bytes']>;\n  repoNamehash_in?: Maybe<Array<Scalars['Bytes']>>;\n  repoNamehash_not_in?: Maybe<Array<Scalars['Bytes']>>;\n  repoNamehash_contains?: Maybe<Scalars['Bytes']>;\n  repoNamehash_not_contains?: Maybe<Scalars['Bytes']>;\n  registryName?: Maybe<Scalars['String']>;\n  registryName_not?: Maybe<Scalars['String']>;\n  registryName_gt?: Maybe<Scalars['String']>;\n  registryName_lt?: Maybe<Scalars['String']>;\n  registryName_gte?: Maybe<Scalars['String']>;\n  registryName_lte?: Maybe<Scalars['String']>;\n  registryName_in?: Maybe<Array<Scalars['String']>>;\n  registryName_not_in?: Maybe<Array<Scalars['String']>>;\n  registryName_contains?: Maybe<Scalars['String']>;\n  registryName_not_contains?: Maybe<Scalars['String']>;\n  registryName_starts_with?: Maybe<Scalars['String']>;\n  registryName_not_starts_with?: Maybe<Scalars['String']>;\n  registryName_ends_with?: Maybe<Scalars['String']>;\n  registryName_not_ends_with?: Maybe<Scalars['String']>;\n};\n\nexport enum Version_OrderBy {\n  Id = 'id',\n  SemanticVersion = 'semanticVersion',\n  CodeAddress = 'codeAddress',\n  ContentUri = 'contentUri',\n  Index = 'index',\n  Timestamp = 'timestamp',\n  TxHash = 'txHash',\n  Sender = 'sender',\n  RepoName = 'repoName',\n  RepoAddress = 'repoAddress',\n  RepoNamehash = 'repoNamehash',\n  RegistryName = 'registryName'\n}\n\nexport type ReposQueryVariables = {};\n\n\nexport type ReposQuery = (\n  { __typename?: 'Query' }\n  & { repos: Array<(\n    { __typename?: 'Repo' }\n    & Pick<Repo, 'id' | 'name' | 'registryName' | 'versionCount'>\n    & { lastVersion?: Maybe<(\n      { __typename?: 'Version' }\n      & Pick<Version, 'semanticVersion' | 'contentUri' | 'timestamp'>\n    )> }\n  )> }\n);\n\nexport type RepoQueryVariables = {\n  id: Scalars['ID'];\n};\n\n\nexport type RepoQuery = (\n  { __typename?: 'Query' }\n  & { repo?: Maybe<(\n    { __typename?: 'Repo' }\n    & Pick<Repo, 'id' | 'name' | 'registryName' | 'timestamp' | 'txHash' | 'sender' | 'versionCount'>\n    & { lastVersion?: Maybe<(\n      { __typename?: 'Version' }\n      & Pick<Version, 'index'>\n    )>, versions?: Maybe<Array<(\n      { __typename?: 'Version' }\n      & Pick<Version, 'index' | 'semanticVersion' | 'contentUri' | 'timestamp' | 'txHash' | 'sender'>\n    )>> }\n  )> }\n);\n\nexport type CountQueryVariables = {};\n\n\nexport type CountQuery = (\n  { __typename?: 'Query' }\n  & { registries: Array<(\n    { __typename?: 'Registry' }\n    & Pick<Registry, 'name' | 'repoCount' | 'versionCount'>\n  )> }\n);\n\nexport type ActivityQueryVariables = {};\n\n\nexport type ActivityQuery = (\n  { __typename?: 'Query' }\n  & { versions: Array<(\n    { __typename?: 'Version' }\n    & Pick<Version, 'timestamp'>\n  )>, repos: Array<(\n    { __typename?: 'Repo' }\n    & Pick<Repo, 'timestamp'>\n  )> }\n);\n\n\nexport const ReposDocument = gql`\n    query Repos {\n  repos(first: 1000) {\n    id\n    name\n    registryName\n    versionCount\n    lastVersion {\n      semanticVersion\n      contentUri\n      timestamp\n    }\n  }\n}\n    `;\nexport type ReposComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<ReposQuery, ReposQueryVariables>, 'query'>;\n\n    export const ReposComponent = (props: ReposComponentProps) => (\n      <ApolloReactComponents.Query<ReposQuery, ReposQueryVariables> query={ReposDocument} {...props} />\n    );\n    \nexport type ReposProps<TChildProps = {}, TDataName extends string = 'data'> = {\n      [key in TDataName]: ApolloReactHoc.DataValue<ReposQuery, ReposQueryVariables>\n    } & TChildProps;\nexport function withRepos<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n  TProps,\n  ReposQuery,\n  ReposQueryVariables,\n  ReposProps<TChildProps, TDataName>>) {\n    return ApolloReactHoc.withQuery<TProps, ReposQuery, ReposQueryVariables, ReposProps<TChildProps, TDataName>>(ReposDocument, {\n      alias: 'repos',\n      ...operationOptions\n    });\n};\n\n/**\n * __useReposQuery__\n *\n * To run a query within a React component, call `useReposQuery` and pass it any options that fit your needs.\n * When your component renders, `useReposQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useReposQuery({\n *   variables: {\n *   },\n * });\n */\nexport function useReposQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<ReposQuery, ReposQueryVariables>) {\n        return ApolloReactHooks.useQuery<ReposQuery, ReposQueryVariables>(ReposDocument, baseOptions);\n      }\nexport function useReposLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<ReposQuery, ReposQueryVariables>) {\n          return ApolloReactHooks.useLazyQuery<ReposQuery, ReposQueryVariables>(ReposDocument, baseOptions);\n        }\nexport type ReposQueryHookResult = ReturnType<typeof useReposQuery>;\nexport type ReposLazyQueryHookResult = ReturnType<typeof useReposLazyQuery>;\nexport type ReposQueryResult = ApolloReactCommon.QueryResult<ReposQuery, ReposQueryVariables>;\nexport const RepoDocument = gql`\n    query Repo($id: ID!) {\n  repo(id: $id) {\n    id\n    name\n    registryName\n    timestamp\n    txHash\n    sender\n    versionCount\n    lastVersion {\n      index\n    }\n    versions {\n      index\n      semanticVersion\n      contentUri\n      timestamp\n      txHash\n      sender\n    }\n  }\n}\n    `;\nexport type RepoComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<RepoQuery, RepoQueryVariables>, 'query'> & ({ variables: RepoQueryVariables; skip?: boolean; } | { skip: boolean; });\n\n    export const RepoComponent = (props: RepoComponentProps) => (\n      <ApolloReactComponents.Query<RepoQuery, RepoQueryVariables> query={RepoDocument} {...props} />\n    );\n    \nexport type RepoProps<TChildProps = {}, TDataName extends string = 'data'> = {\n      [key in TDataName]: ApolloReactHoc.DataValue<RepoQuery, RepoQueryVariables>\n    } & TChildProps;\nexport function withRepo<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n  TProps,\n  RepoQuery,\n  RepoQueryVariables,\n  RepoProps<TChildProps, TDataName>>) {\n    return ApolloReactHoc.withQuery<TProps, RepoQuery, RepoQueryVariables, RepoProps<TChildProps, TDataName>>(RepoDocument, {\n      alias: 'repo',\n      ...operationOptions\n    });\n};\n\n/**\n * __useRepoQuery__\n *\n * To run a query within a React component, call `useRepoQuery` and pass it any options that fit your needs.\n * When your component renders, `useRepoQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useRepoQuery({\n *   variables: {\n *      id: // value for 'id'\n *   },\n * });\n */\nexport function useRepoQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<RepoQuery, RepoQueryVariables>) {\n        return ApolloReactHooks.useQuery<RepoQuery, RepoQueryVariables>(RepoDocument, baseOptions);\n      }\nexport function useRepoLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<RepoQuery, RepoQueryVariables>) {\n          return ApolloReactHooks.useLazyQuery<RepoQuery, RepoQueryVariables>(RepoDocument, baseOptions);\n        }\nexport type RepoQueryHookResult = ReturnType<typeof useRepoQuery>;\nexport type RepoLazyQueryHookResult = ReturnType<typeof useRepoLazyQuery>;\nexport type RepoQueryResult = ApolloReactCommon.QueryResult<RepoQuery, RepoQueryVariables>;\nexport const CountDocument = gql`\n    query Count {\n  registries {\n    name\n    repoCount\n    versionCount\n  }\n}\n    `;\nexport type CountComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<CountQuery, CountQueryVariables>, 'query'>;\n\n    export const CountComponent = (props: CountComponentProps) => (\n      <ApolloReactComponents.Query<CountQuery, CountQueryVariables> query={CountDocument} {...props} />\n    );\n    \nexport type CountProps<TChildProps = {}, TDataName extends string = 'data'> = {\n      [key in TDataName]: ApolloReactHoc.DataValue<CountQuery, CountQueryVariables>\n    } & TChildProps;\nexport function withCount<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n  TProps,\n  CountQuery,\n  CountQueryVariables,\n  CountProps<TChildProps, TDataName>>) {\n    return ApolloReactHoc.withQuery<TProps, CountQuery, CountQueryVariables, CountProps<TChildProps, TDataName>>(CountDocument, {\n      alias: 'count',\n      ...operationOptions\n    });\n};\n\n/**\n * __useCountQuery__\n *\n * To run a query within a React component, call `useCountQuery` and pass it any options that fit your needs.\n * When your component renders, `useCountQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useCountQuery({\n *   variables: {\n *   },\n * });\n */\nexport function useCountQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<CountQuery, CountQueryVariables>) {\n        return ApolloReactHooks.useQuery<CountQuery, CountQueryVariables>(CountDocument, baseOptions);\n      }\nexport function useCountLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<CountQuery, CountQueryVariables>) {\n          return ApolloReactHooks.useLazyQuery<CountQuery, CountQueryVariables>(CountDocument, baseOptions);\n        }\nexport type CountQueryHookResult = ReturnType<typeof useCountQuery>;\nexport type CountLazyQueryHookResult = ReturnType<typeof useCountLazyQuery>;\nexport type CountQueryResult = ApolloReactCommon.QueryResult<CountQuery, CountQueryVariables>;\nexport const ActivityDocument = gql`\n    query Activity {\n  versions(first: 1000) {\n    timestamp\n  }\n  repos(first: 1000) {\n    timestamp\n  }\n}\n    `;\nexport type ActivityComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<ActivityQuery, ActivityQueryVariables>, 'query'>;\n\n    export const ActivityComponent = (props: ActivityComponentProps) => (\n      <ApolloReactComponents.Query<ActivityQuery, ActivityQueryVariables> query={ActivityDocument} {...props} />\n    );\n    \nexport type ActivityProps<TChildProps = {}, TDataName extends string = 'data'> = {\n      [key in TDataName]: ApolloReactHoc.DataValue<ActivityQuery, ActivityQueryVariables>\n    } & TChildProps;\nexport function withActivity<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n  TProps,\n  ActivityQuery,\n  ActivityQueryVariables,\n  ActivityProps<TChildProps, TDataName>>) {\n    return ApolloReactHoc.withQuery<TProps, ActivityQuery, ActivityQueryVariables, ActivityProps<TChildProps, TDataName>>(ActivityDocument, {\n      alias: 'activity',\n      ...operationOptions\n    });\n};\n\n/**\n * __useActivityQuery__\n *\n * To run a query within a React component, call `useActivityQuery` and pass it any options that fit your needs.\n * When your component renders, `useActivityQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useActivityQuery({\n *   variables: {\n *   },\n * });\n */\nexport function useActivityQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<ActivityQuery, ActivityQueryVariables>) {\n        return ApolloReactHooks.useQuery<ActivityQuery, ActivityQueryVariables>(ActivityDocument, baseOptions);\n      }\nexport function useActivityLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<ActivityQuery, ActivityQueryVariables>) {\n          return ApolloReactHooks.useLazyQuery<ActivityQuery, ActivityQueryVariables>(ActivityDocument, baseOptions);\n        }\nexport type ActivityQueryHookResult = ReturnType<typeof useActivityQuery>;\nexport type ActivityLazyQueryHookResult = ReturnType<typeof useActivityLazyQuery>;\nexport type ActivityQueryResult = ApolloReactCommon.QueryResult<ActivityQuery, ActivityQueryVariables>;","import React from \"react\";\nimport { GoPackage } from \"react-icons/go\";\nimport { MdUpdate } from \"react-icons/md\";\nimport { useCountQuery } from \"generated/graphql\";\nimport \"./summary-stats.scss\";\n\nexport default function SummaryStats() {\n  const { data } = useCountQuery();\n\n  const registries = data?.registries || [];\n  const packageCount = registries.reduce(\n    (total, reg) => total + reg.repoCount,\n    0\n  );\n  const versionCount = registries.reduce(\n    (total, reg) => total + reg.versionCount,\n    0\n  );\n\n  const cards = [\n    { title: \"Published packages\", stat: packageCount, Icon: GoPackage },\n    { title: \"Published versions\", stat: versionCount, Icon: MdUpdate },\n  ];\n\n  return (\n    <div className=\"summary-stats\">\n      {cards.map(({ title, stat, Icon }) => (\n        <div key={title} className=\"card\">\n          <span className=\"title\">{title}</span>\n          <span className=\"stat\">{stat}</span>\n          <span className=\"icon\">\n            <Icon />\n          </span>\n        </div>\n      ))}\n    </div>\n  );\n}\n","import React from \"react\";\n\ninterface Settings {\n  ipfsGateway: string;\n  ipfsApi: string;\n  txViewer: string;\n}\n\nconst SettingsContext = React.createContext<Settings>({\n  ipfsGateway: \"https://gateway.ipfs.dappnode.io\",\n  ipfsApi: \"https://infura-ipfs.io:5001\",\n  txViewer: \"https://etherscan.io/tx\",\n});\n\nexport const SettingsProvider = SettingsContext.Provider;\nexport const SettingsConsumer = SettingsContext.Consumer;\n\nexport default SettingsContext;\n","/**\n * Capitalizes a string\n * @param string = \"hello world\"\n * @returns \"Hello world\"\n */\nfunction capitalize(s: string): string {\n  if (!s || typeof s !== \"string\") return s;\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\n\n/**\n * Pretifies a package name\n * \"bitcoin\" => \"Bitcoin\"\n * \"raiden-testnet\" => \"Raiden Testnet\"\n *\n * @param name ENS name\n * @returns pretty name\n */\nexport function prettyName(name: string): string {\n  return (\n    name\n      // Convert all \"-\" and \"_\" to spaces\n      .replace(/-/g, \" \")\n      .replace(/_/g, \" \")\n      .replace(/\\./g, \" \")\n      .split(\" \")\n      .map(capitalize)\n      .join(\" \")\n  );\n}\n\n/**\n * Pretifies a ENS name\n * \"bitcoin.dnp.dappnode.eth\" => \"Bitcoin\"\n * \"raiden-testnet.dnp.dappnode.eth\" => \"Raiden Testnet\"\n *\n * @param name ENS name\n * @returns pretty name\n */\nexport function parseRepoName(\n  name: string\n): { registry: string; prettyName: string } {\n  const [shortName, registry] = name.split(/\\.(.+)/);\n\n  return {\n    prettyName: prettyName(shortName),\n    registry,\n  };\n}\n\n/**\n * Returns a shortened address\n * @param address \"0x12345678901234567890123456789\"\n * @returns \"0x1234...6789\"\n */\nexport function prettyAddress(address: string) {\n  return `${address.slice(0, 6)}...${address.slice(-4)}`;\n}\n\n/**\n * TheGraph sends the version concatenated by comma \",\"\n * @param semanticVersion \"0,1,18\"\n * @returns \"0.1.18\"\n */\nexport function semanticVersionDots(semanticVersion: string): string {\n  return semanticVersion.replace(/,/g, \".\");\n}\n","/**\n * Joins multiple url parts safely\n * - Does not break the protocol double slash //\n * - Cleans double slashes at any point\n * @param args (\"http://ipfs.io\", \"ipfs\", \"Qm\")\n * @return \"http://ipfs.io/ipfs/Qm\"\n */\nexport function urlJoin(...args: string[]): string {\n  return args.join(\"/\").replace(/([^:]\\/)\\/+/g, \"$1\");\n}\n\n/**\n * Clean an IPFS hash of prefixes and suffixes commonly found\n * in both gateway URLs and content URLs\n * @param ipfsDirtyHash\n */\nexport function stipIpfsPrefix(ipfsDirtyHash: string): string {\n  return (\n    ipfsDirtyHash\n      // Trim ending /ipfs/ tag\n      // \"site.io:8080//ipfs//\" => \"site.io:8080\"\n      .replace(/\\/*ipfs\\/*$/, \"\")\n      // Trim starting /ipfs/, ipfs: tag\n      // \"/ipfs/Qm\" => \"Qm\"\n      .replace(/^\\/*ipfs[/:]*/, \"\")\n  );\n}\n\n/**\n * Returns a joined IPFS location given an IPFS gateway and an IPFS path\n * This util makes sure the url is properly joined, and that it contains\n * the \"ipfs\" route only once, stripping it from the gateway and the location\n * @param ipfsGateway \"https://ipfs.io\"\n * @param location \"Qmzz\"\n * @return \"https://ipfs.io/ipfs/Qmzz/artifact.json\"\n */\nexport function joinIpfsLocation(\n  ipfsGateway: string,\n  location: string\n): string {\n  return urlJoin(stipIpfsPrefix(ipfsGateway), \"ipfs\", stipIpfsPrefix(location));\n}\n","import React from \"react\";\nimport moment from \"moment\";\n\n/**\n * Display last time an event happened nicely\n */\nexport function TimeDisplay({ timestamp }: { timestamp?: number }) {\n  if (!timestamp) return <div>-</div>;\n  const time = moment(timestamp * 1000);\n  return (\n    <>\n      <div>{time.calendar()}</div>\n      <div className=\"light\">{time.fromNow()}</div>\n    </>\n  );\n}\n","import React, { useContext, useEffect, useState } from \"react\";\nimport { useHistory } from \"react-router-dom\";\nimport SettingsContext from \"settingsContext\";\nimport { prettyName, semanticVersionDots } from \"utils/format\";\nimport { urlJoin } from \"utils/url\";\nimport { TimeDisplay } from \"components/TimeDisplay\";\nimport { useReposQuery } from \"generated/graphql\";\nimport \"./summary-table.scss\";\n\nconst showInterval = 20;\n\nexport default function SummaryTable() {\n  const [showIndex, setShowIndex] = useState(showInterval);\n  const history = useHistory();\n  const { ipfsGateway } = useContext(SettingsContext);\n  const reposSummary = useReposQuery();\n\n  // Detect bottom scroll event\n  useEffect(() => {\n    function onScroll() {\n      if (\n        window.innerHeight + document.documentElement.scrollTop >\n        document.documentElement.offsetHeight * 0.99\n      )\n        setShowIndex((x) => x + showInterval);\n    }\n    if (reposSummary.data && reposSummary.data.repos.length > showIndex)\n      document.addEventListener(\"scroll\", onScroll);\n\n    return () => {\n      document.removeEventListener(\"scroll\", onScroll);\n    };\n  }, [showIndex, reposSummary.data]);\n\n  if (reposSummary.data) {\n    const { repos } = reposSummary.data;\n    return (\n      <div className=\"table-container\">\n        <table className=\"summary-table\">\n          <thead>\n            <tr>\n              <th className=\"logo\"></th>\n              <th>Name</th>\n              <th>Last updated</th>\n              <th>Last version</th>\n              <th className=\"registry\">Registry</th>\n            </tr>\n          </thead>\n          <tbody>\n            {repos\n              .sort(\n                (a, b) =>\n                  (b.lastVersion?.timestamp || 0) -\n                  (a.lastVersion?.timestamp || 0)\n              )\n              .slice(0, showIndex)\n              .map(({ id, name, registryName, versionCount, lastVersion }) => (\n                <tr key={id} onClick={() => history.push(`/repo/${id}`)}>\n                  <td className=\"logo\">\n                    {lastVersion && (\n                      <img\n                        src={urlJoin(\n                          ipfsGateway,\n                          lastVersion.contentUri,\n                          \"avatar.png\"\n                        )}\n                        alt=\"logo\"\n                      />\n                    )}{\" \"}\n                  </td>\n                  <td>\n                    <div>{prettyName(name)}</div>\n                    <div className=\"registry-under-name\">\n                      <RegistryDisplay registry={registryName} small />\n                    </div>\n                  </td>\n                  <td>\n                    <TimeDisplay timestamp={lastVersion?.timestamp} />\n                  </td>\n                  <td>\n                    {lastVersion ? (\n                      <>\n                        <div>\n                          {semanticVersionDots(lastVersion.semanticVersion)}\n                        </div>\n                        <div className=\"light\">{versionCount}</div>\n                      </>\n                    ) : (\n                      <div>-</div>\n                    )}\n                  </td>\n                  <td className=\"registry\">\n                    <RegistryDisplay registry={registryName} />\n                  </td>\n                </tr>\n              ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  if (reposSummary.error) return <div>{reposSummary.error.message}</div>;\n  if (reposSummary.loading) return <div>Loading...</div>;\n  return null;\n}\n\nfunction prettyRegistry(registry: string) {\n  return registry === \"dnp.dappnode.eth\"\n    ? \"dnp\"\n    : registry === \"public.dappnode.eth\"\n    ? \"public\"\n    : undefined;\n}\n\n/**\n * Display registry as a colored pill by name\n */\nfunction RegistryDisplay({\n  registry,\n  small,\n}: {\n  registry: string;\n  small?: boolean;\n}) {\n  const shortName = prettyRegistry(registry);\n  return (\n    <div className={`registry-badge ${small ? \"small\" : \"\"}`}>\n      <span className={shortName}>{shortName || registry}</span>\n    </div>\n  );\n}\n","/**\n * Histogram by timestamp of an array of objects\n * @param items\n * @returns byMonth = [ { month: 4, value: 29 },\n *  { month: 5, value: 19 },\n *  { month: 6, value: 13 },\n *  { month: 7, value: 10 },\n *  { month: 8, value: 26 },\n *  { month: 9, value: 24 },\n *  { month: 10, value: 53 },\n *  { month: 11, value: 38 },\n *  { month: 0, value: 38 },\n *  { month: 1, value: 21 },\n *  { month: 2, value: 14 },\n *  { month: 3, value: 12 }\n * ]\n */\nexport function aggregateLast12Months<T extends { timestamp?: number }>(\n  items: T[]\n) {\n  const getFullMonth = (date: Date) =>\n    date.getFullYear() * 12 + date.getMonth();\n\n  const byTime: { [fullMonth: number]: number } = {};\n  for (const item of items)\n    if (item.timestamp) {\n      const fullMonth = getFullMonth(new Date(item.timestamp * 1000));\n      byTime[fullMonth] = (byTime[fullMonth] || 0) + 1;\n    }\n\n  const currentFullMonth = getFullMonth(new Date());\n  const aggregate: { month: number; count: number }[] = [];\n  for (let i = currentFullMonth - 11; i <= currentFullMonth; i++)\n    aggregate.push({ month: i % 12, count: byTime[i] || 0 });\n\n  return aggregate;\n}\n","import React from \"react\";\nimport ActivityChart from \"components/ActivityChart\";\nimport SummaryStats from \"components/SummaryStats\";\nimport SummaryTable from \"components/SummaryTable\";\nimport { useActivityQuery } from \"generated/graphql\";\nimport { aggregateLast12Months } from \"utils/math\";\n\nexport function Home() {\n  const activityQuery = useActivityQuery();\n\n  const versions = activityQuery.data?.versions || [];\n  const packages = activityQuery.data?.repos || [];\n  const activity = {\n    versions: aggregateLast12Months(versions),\n    packages: aggregateLast12Months(packages),\n  };\n\n  return (\n    <>\n      <ActivityChart activity={activity} />\n      <SummaryStats />\n      <SummaryTable />\n    </>\n  );\n}\n","import ky from \"ky\";\nimport { ApmVersion } from \"types\";\n\ninterface ObjectStat {\n  Hash: string; // \"QmUPJwSa867iJW2MQxrUY8Y72jaFkj7wk2RVMiPtWEotsy\"\n  NumLinks: number; // 8\n  BlockSize: number; // 511\n  LinksSize: number; // 509\n  DataSize: number; // 2\n  CumulativeSize: number; // 22972396\n}\n\n/**\n * Check if a version hash is available by calling an IFPS gateway\n * @param version\n * @param ipfsApi\n */\nexport async function isVersionAvailable(\n  version: ApmVersion,\n  { ipfsApi }: { ipfsApi: string }\n): Promise<boolean> {\n  try {\n    const url = `${ipfsApi}/api/v0/object/stat?arg=${version.contentUri}`;\n    const stat: ObjectStat = await ky(url, { timeout: 5000 }).json();\n    return Boolean(stat.CumulativeSize);\n  } catch (e) {\n    console.log(\n      `Version ${version.semanticVersion} ${version.contentUri} not available: ${e.message}`\n    );\n    return false;\n  }\n}\n","import React from \"react\";\nimport { FaCircle } from \"react-icons/fa\";\nimport \"./statusBubble.scss\";\n\nexport function StatusBubble({ ok }: { ok?: boolean }) {\n  const status = ok === true ? \"ok\" : ok === false ? \"nok\" : \"\";\n  return (\n    <span className={`status-bubble ${status}`}>\n      <FaCircle />\n    </span>\n  );\n}\n","import React from \"react\";\nimport { MdOpenInNew } from \"react-icons/md\";\nimport \"./externalLink.scss\";\n\nexport function ExternalLink({ url }: { url: string }) {\n  return (\n    <a\n      className=\"external-link\"\n      href={url}\n      rel=\"noopener noreferrer\"\n      target=\"_blank\"\n    >\n      <MdOpenInNew />\n    </a>\n  );\n}\n","import React from \"react\";\nimport makeBlockie from \"ethereum-blockies-base64\";\nimport { prettyAddress } from \"utils/format\";\nimport \"./addressDisplay.scss\";\n\nexport function AddressDisplay({ address }: { address?: string }) {\n  return (\n    <div className=\"address-display\">\n      {address && <img className=\"blockie\" src={makeBlockie(address)} alt=\"\" />}\n      <span>{address ? prettyAddress(address) : \"\"}</span>\n    </div>\n  );\n}\n","import React, { useContext } from \"react\";\nimport { ApmVersion } from \"types\";\nimport SettingsContext from \"settingsContext\";\nimport { joinIpfsLocation } from \"utils/url\";\nimport \"./versionDisplay.scss\";\n\nexport function VersionDisplay({\n  version,\n  isLatest,\n}: {\n  version: ApmVersion;\n  isLatest: boolean;\n}) {\n  const { ipfsGateway } = useContext(SettingsContext);\n  const { contentUri } = version;\n\n  return (\n    <div className=\"version-display\">\n      <div className=\"header\">\n        <div className=\"title\">\n          {version.semanticVersion} {isLatest ? \"(latest)\" : \"\"}\n        </div>\n        <div className=\"contentUri\">{contentUri}</div>\n      </div>\n      <iframe\n        className=\"content-preview\"\n        name=\"version-content\"\n        id=\"version-content\"\n        title=\"version-content\"\n        src={joinIpfsLocation(ipfsGateway, contentUri)}\n        frameBorder={0}\n      ></iframe>\n    </div>\n  );\n}\n","import React, { useState, useEffect, useContext } from \"react\";\nimport { RouteComponentProps, useHistory } from \"react-router-dom\";\nimport SettingsContext from \"settingsContext\";\nimport { prettyName, semanticVersionDots } from \"utils/format\";\nimport { urlJoin, joinIpfsLocation } from \"utils/url\";\nimport { isVersionAvailable } from \"utils/isVersionAvailable\";\nimport { StatusBubble } from \"components/StatusBubble\";\nimport { TimeDisplay } from \"components/TimeDisplay\";\nimport { ExternalLink } from \"components/ExternalLink\";\nimport { AddressDisplay } from \"components/AddressDisplay\";\nimport { VersionDisplay } from \"components/VersionDisplay\";\nimport { useRepoQuery } from \"generated/graphql\";\nimport \"./repoViewer.scss\";\n\ninterface VersionAvailable {\n  [version: string]: boolean;\n}\n\nexport const Repo: React.FC<RouteComponentProps<{\n  repoId: string;\n  versionId: string;\n}>> = ({ match }) => {\n  const [isAvailable, setIsAvailable] = useState<VersionAvailable>({});\n  const [analyze, setAnalyze] = useState(false);\n\n  const history = useHistory();\n  const { ipfsGateway, ipfsApi, txViewer } = useContext(SettingsContext);\n\n  const { repoId, versionId } = match.params;\n  const repoQuery = useRepoQuery({ variables: { id: repoId } });\n  const repoData = repoQuery.data?.repo;\n\n  useEffect(() => {\n    async function checkVersionAvailability() {\n      if (repoData && repoData.versions) {\n        for (const _version of repoData.versions) {\n          const available = await isVersionAvailable(_version, { ipfsApi });\n          setIsAvailable((x) => ({\n            ...x,\n            [_version.semanticVersion]: available,\n          }));\n        }\n      }\n    }\n    if (analyze) checkVersionAvailability();\n  }, [ipfsApi, repoData, analyze]);\n\n  function selectVersion(_version: string) {\n    history.push(`/repo/${repoId}/${_version}`);\n  }\n\n  if (repoQuery.data && repoData) {\n    // Alias\n    const versions = (repoData.versions || [])\n      .sort((a, b) => b.index - a.index)\n      .map((version) => ({\n        ...version,\n        // TheGraph sends the version concatenated by comma \",\"\n        semanticVersion: semanticVersionDots(version.semanticVersion),\n      }));\n\n    // Add another \"Creation\" version if the creation tx is different\n    const firstVersion = versions[versions.length - 1];\n    if (firstVersion.txHash && repoData.txHash !== firstVersion.txHash) {\n      versions.push({\n        semanticVersion: \"Creation\",\n        index: -1,\n        contentUri: \"\",\n        timestamp: repoData.timestamp,\n        txHash: repoData.txHash,\n        sender: repoData.sender,\n      });\n    }\n\n    const latestVersionIndex = repoData.lastVersion?.index;\n    const versionDisplay =\n      versions.find((v) => v.semanticVersion === versionId) ||\n      versions[0] ||\n      undefined;\n    const isLatest =\n      versionDisplay && versionDisplay.index === latestVersionIndex;\n\n    return (\n      <>\n        <div>\n          <div className=\"repo-name\">{prettyName(repoData.name)}</div>\n          <div className=\"registry\">{repoData.registryName}</div>\n        </div>\n\n        {versionDisplay && (\n          <VersionDisplay version={versionDisplay} isLatest={isLatest} />\n        )}\n\n        <div className=\"table-container\">\n          <table className=\"summary-table\">\n            <thead>\n              <tr>\n                <th>Version</th>\n                <th>Age</th>\n                <th onClick={() => setAnalyze(true)}>Content</th>\n                <th>From</th>\n                <th>Txn</th>\n              </tr>\n            </thead>\n            <tbody>\n              {versions.map(\n                ({\n                  semanticVersion,\n                  contentUri,\n                  timestamp,\n                  txHash,\n                  sender,\n                }) => (\n                  <tr\n                    key={semanticVersion}\n                    onClick={() => selectVersion(semanticVersion)}\n                  >\n                    <td>{semanticVersion}</td>\n                    <td>\n                      <TimeDisplay timestamp={timestamp} />\n                    </td>\n                    <td className=\"content\">\n                      {analyze && (\n                        <StatusBubble ok={isAvailable[semanticVersion]} />\n                      )}\n                      {contentUri && (\n                        <ExternalLink\n                          url={joinIpfsLocation(ipfsGateway, contentUri)}\n                        />\n                      )}\n                    </td>\n                    <td>\n                      <AddressDisplay address={sender} />\n                    </td>\n                    <td className=\"txn\">\n                      {txHash && (\n                        <ExternalLink url={urlJoin(txViewer, txHash)} />\n                      )}\n                    </td>\n                  </tr>\n                )\n              )}\n            </tbody>\n          </table>\n        </div>\n      </>\n    );\n  }\n\n  if (repoQuery.error) return <div>{repoQuery.error.message}</div>;\n  if (repoQuery.loading) return <div>Loading...</div>;\n  return null;\n};\n","import React from \"react\";\nimport { Route } from \"react-router-dom\";\nimport Header from \"./components/Header\";\nimport { Home } from \"./pages/Home\";\nimport { Repo } from \"./pages/Repo\";\n\nexport default function App() {\n  return (\n    <div className=\"App\">\n      <Header />\n      <div className=\"app-body\">\n        <Route path=\"/\" exact component={Home} />\n        <Route path=\"/repo/:repoId/:versionId?\" component={Repo} />\n      </div>\n    </div>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { HashRouter as Router } from \"react-router-dom\";\nimport ApolloClient from \"apollo-boost\";\nimport { ApolloProvider } from \"react-apollo\";\nimport { ApolloProvider as ApolloHooksProvider } from \"react-apollo-hooks\";\nimport \"./index.css\";\nimport \"./style.scss\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst client = new ApolloClient({\n  uri:\n    \"https://api.studio.thegraph.com/query/90626/dappnode-explorer/v0.1.0/\",\n});\n\nReactDOM.render(\n  <ApolloProvider client={client}>\n    <ApolloHooksProvider client={client}>\n      <Router>\n        <App />\n      </Router>\n    </ApolloHooksProvider>\n  </ApolloProvider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}